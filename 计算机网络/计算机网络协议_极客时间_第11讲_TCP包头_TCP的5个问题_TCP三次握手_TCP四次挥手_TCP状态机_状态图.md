# 第11讲 | TCP协议（上）：因性恶而复杂，先恶后善反轻松

UDP，基本上包括了传输层所必须的端口字段。

TCP 协议很复杂，它天然认为网络环境是恶劣的，**丢包、乱序、重传，拥塞**都是常有的事情，一言不合就可能送达不了，因而要从**算法层面**来保证可靠性。

---

### TCP 包头格式

比 UDP 复杂得多。

- 首先，源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。如果**没有这两个端口号**，数据就不知道应该**发给哪个应用**。

- 接下来是包的序号。为什么要给包编号呢？为了**解决乱序的问题**。不编好号怎么确认哪个应该先来，哪个应该后到呢。

- 还有的就是**确认序号**，发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以**解决不丢包的问题**。

从 **IP 层面**来讲，如果网络状况的确那么差，是没有任何可靠性保证的，而**作为 IP 的上一层 TCP 也无能为力**，唯一能做的就是更加努力，不断**重传**，通过各种**算法保证**。

对于 TCP 来讲，**IP 层你丢不丢包**，我管不着，但是我在我的层面上，会努力**保证可靠性**。

- 接下来有一些**状态位**。例如 **SYN 是发起一个连接**，**ACK 是回复**，**RST 是重新连接**，**FIN 是结束连接**等。

**TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更**。

- 还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方**各声明一个窗口**，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

- 除了做流量控制以外，TCP 还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，**唯一能做的就是控制自己**，也即**控制发送的速度**。

  ---

  要**掌握 TCP 协议**，重点应该关注以下几个问题：

  - 顺序问题 ，稳重不乱；
  - 丢包问题，承诺靠谱；
  - 连接维护，有始有终；
  - 流量控制，把握分寸；
  - 拥塞控制，知进知退。



---

### TCP 的三次握手

所有的问题，首先**都要先建立一个连接**，所以我们先来看**连接维护问题**。

![image-20200620143643797](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200620143643797.png)

**“请求 -> 应答 -> 应答之应答”的三个回合**。

所以**四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以**了。

>  不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启 keepalive 机制，即使没有真实的数据包，也有探活包。

> 作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。

三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是 **TCP 包的序号的问题**。

A 要告诉 B，我这面发起的包的**序号起始是从哪个号开始的**，B 同样也要告诉 A，B 发起的包的**序号起始是从哪个号开始的**。为什么序号**不能都从 1 开始**呢？因为这样往往会出现**冲突**。

> 例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。

因而，**每个连接都要有不同的序号**。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4ms 加一，**如果到重复，需要 4 个多小时**，那个绕路的包早就死翘翘了，因为我们都知道 **IP 包头里面有个 TTL，也即生存时间**。

---

双方终于建立了信任，建立了连接。为了维护这个连接，双方都要维护一个**状态机**，在连接建立的过程中，双方的状态变化时序图就像这样。

- 一开始，客户端和服务端都处于 CLOSED 状态。
- 先是服务端主动监听某个端口，处于 LISTEN 状态。
- 然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。
- 服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。
- 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它**一发一收成功了**。
- 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也**一发一收了**。

---

### TCP 四次挥手

![image-20200620144318509](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200620144318509.png)

这个时候，还只是 A 不想玩了，也即 **A 不会再发送数据**，但是 B 能不能在 ACK 的时候，直接关闭呢？**当然不可以**，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为**半关闭的状态**。

这个时候 A **可以选择不再接收数据**了，也可以**选择最后再接收一段数据**，等待 **B 也主动关闭**。

![image-20200620144451405](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200620144451405.png)

这样**整个连接就关闭**了。

#### 2种异常情况

- 一种情况是，**A** 说完“不玩了”之后，**直接跑路**，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，**B 就不知道该怎么办了**。

- 另一种情况是，A 说完“不玩了”，**B 直接跑路**，也是有问题的，因为 **A 不知道** B 是还有事情要处理，还是过一会儿会发送结束。

> 当 A 说“不玩了”，就进入 **FIN_WAIT_1 的状态**，B 收到“A 不玩”的消息后，发送知道了，就进入 CLOSE_WAIT 的状态。

> A 收到“**B 说知道了**”，就**进入 FIN_WAIT_2 的状态**，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 t**cp_fin_timeout 这个参数，设置一个超时时间**。

A 直接跑路还有一个问题是，**A 的端口就直接空出来了**，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，**这个新的应用会收到上个连接中 B 发过来的包**，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而**也需要等足够长的时间**，等到**原来 B 发送的所有的包**都死翘翘，再**空出端口**来。

---

> 如果 B 没有跑路，发送了“B 也不玩了”的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从 **FIN_WAIT_2 状态结束**，按说 A 可以跑路了，但是**最后的这个 ACK 万一 B 收不到呢**？则 B 会重新发一个“B 不玩了”，这个时候 A 已经跑路了的话，**B 就再也收不到 ACK 了**，因而 **TCP 协议要求 A 最后等待一段时间 TIME_WAIT**，这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，**A 会重新发一个 ACK 并且足够时间到达 B**。

---

等待的时间设为 **2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，**它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

因为 **TCP 报文基于是 IP 协议的**，而 **IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数**。

每经过一个处理他的路由器此值就减 1，当**此值为 0 则数据报将被丢弃**，同时**发送 ICMP 报文通知源主机**。协议规定 **MSL** 为 2 分钟，实际应用中**常用的是 30 秒**，1 分钟和 2 分钟等。

> 还有一个**异常情况**就是，B 超过了 2MSL 的时间，**依然没有收到它发的 FIN 的 ACK**，怎么办呢？
>
> 按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就**直接发送 RST，B 就知道 A 早就跑了**。

---

### TCP 状态机

将**连接建立**和**连接断开**的两个时序状态图综合起来，就是这个著名的 TCP 的状态机。

---

#### 小结

- **TCP 包头**很复杂，但是主要关注**五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制**；

- 连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的那个**状态图**。