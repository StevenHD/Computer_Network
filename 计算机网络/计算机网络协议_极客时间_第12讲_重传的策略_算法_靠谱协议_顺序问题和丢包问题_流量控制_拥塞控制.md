# 第12讲 | TCP协议（下）：西行必定多妖孽，恒心智慧消磨难

出了网关，那就是在公网上传输数据，公网往往是不可靠的。

需要很多的机制去**保证传输的可靠性**，这里面需要**各种重传的策略**，还需要包含着**大量的算法**。

**客户端每发送的一个包，服务器端都应该有个回复，如果服务器端超过一定的时间没有回复，客户端就会重新发送这个包，直到有回复**。

这个发送应答的过程是什么样呢？可以是**上一个收到了应答，再发送下一个**。

---

### 如何实现一个靠谱的协议？

TCP 协议为了**保证顺序性**，**每一个包都有一个 ID**。

为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是应答**某个之前的 ID**，表示都收到了，这种模式称为**累计确认或者累计应答（cumulative acknowledgment）**。

为了**记录所有发送的包和接收的包**，TCP 也需要**发送端和接收端分别都有缓存**来保存这些记录。发送端的缓存里是**按照包的 ID 一个个排列**，根据处理的情况分成四个部分。

- 发送了并且已经确认的
- 发送了并且尚未确认的
- 没有发送，但是已经等待发送的
- 没有发送，并且暂时还不会发送的

在 TCP 里，**接收端会给发送端报一个窗口的大小，叫 Advertised window**。这个窗口的大小应该等于上面的第二部分加上第三部分。**超过这个窗口的，接收端做不过来，就不能发送了**。

---

### 顺序问题与丢包问题

顺序问题和丢包问题都有可能发生，所以我们先来看**确认与重发的机制**。

- 一种方法就是**超时重试**，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。

> 但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。
>
> 估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为**自适应重传算法（Adaptive Retransmission Algorithm）**。

TCP 的策略是**超时间隔加倍**。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

**超时触发重传存在的问题**是，**超时周期**可能相对较长。那是不是可以有更快的方式呢？

- 有一个可以**快速重传**的机制

> 例如，接收方发现 6 收到了，8 也收到了，但是 7 还没来，那肯定是丢了，于是发送 6 的 ACK，要求下一个是 7。接下来，收到后续的包，仍然发送 6 的 ACK，要求下一个是 7。当客户端收到 3 个重复 ACK，就会发现 7 的确丢了，不等超时，马上重发。

- 还有一种方式称为 **Selective Acknowledgment （SACK）**。

  > 这种方式需要在 TCP 头里加一个 **SACK 的东西**，可以**将缓存的地图发送给发送方**。例如可以发送 ACK6、SACK8、SACK9，有了地图，**发送方一下子就能看出来是 7 丢了**。

---

### 流量控制问题

来看**流量控制机制**，在对于**包的确认中，同时会携带一个窗口的大小**。

发送方会定时发送**窗口探测数据包**，看是否有机会**调整窗口的大小**。

> 当**接收方**比较慢的时候，要防止**低能窗口综合征**，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到**达到一定大小，或者缓冲区一半为空，才更新窗口**。

---

### 拥塞控制问题

拥塞控制的问题，也是通过**窗口的大小来控制**的，前面的滑动窗口 rwnd 是**怕发送方把接收方缓存塞满**，而拥塞窗口 cwnd，是**怕把网络塞满**。

**TCP 发送包**常被比喻为往一个水管里面灌水，而 **TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽**。

水管有粗细，网络有带宽，也即**每秒钟能够发送多少数据**；

水管有长度，端到端有时延。

在理想状态下，**水管里面水的量 = 水管粗细 x 水管长度**。

对于到网络上，**通道的容量 = 带宽 × 往返延迟**。

TCP 的拥塞控制主要来避免**两种现象**，**包丢失**和**超时重传**。

> 如果我们通过漏斗往瓶子里灌水，我们就知道，**不能一桶水一下子倒进去，肯定会溅出来**，要一开始慢慢的倒，然后发现总能够倒进去，就可以越倒越快。这叫作**慢启动**。

> 一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是**指数性的增长**。
>
> > 涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。

每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了**线性增长**。

> 但是线性增长还是增长，还是越来越多，直到有一天，**水满则溢，出现了拥塞**，这时候一般就会**一下子降低倒水的速度**，等待溢出的水慢慢渗下去。

**拥塞的一种表现形式是丢包**，需要**超时重传**，但是这种方式太激进了，**将一个高速的传输速度一下子停了下来，会造成网络卡顿**。

前面我们讲过**快速重传算法**。

---

TCP 的**拥塞控制**主要来避免的**两个现象**都是有问题的。

**第一个问题**是**丢包并不代表着通道满了**，也可能是**管子本来就漏水**。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。

**第二个问题**是 **TCP 的拥塞控制要等到将中间设备都填充满了**，才发生**丢包**，从而降低速度，这时候已经晚了。**其实 TCP 只要填满管道**就可以了，不应该接着填，直到连缓存也填满。

为了优化这两个问题，后来有了 **TCP BBR 拥塞算法**。它企图找到一个平衡点，就是通**过不断地加快发送速度，将管道填满，但是不要填满中间设备的缓存**，因为这样**时延会增加**，在这个平衡点可以很好的达到**高带宽和低时延的平衡**。

![img](https://static001.geekbang.org/resource/image/a2/4c/a2b3a5df5eca52e302b75824e4bbbd4c.jpg)

---

#### 小结

- **顺序问题、丢包问题、流量控制**都是通过**滑动窗口**来解决的，这其实就相当于你领导和你的工作备忘录，**布置过的工作要有编号，干完了有反馈**，活不能派**太多**，也不能**太少**；

- 拥塞控制是通过**拥塞窗口**来解决的，相当于**往管道里面倒水，快了容易溢出，慢了浪费带宽**，要摸着石头过河，找到**最优值**。